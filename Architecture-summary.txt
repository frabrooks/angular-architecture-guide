Architecture summary (NgRx best practice + signals)
Principles

NgRx Store/Effects own orchestration: async, side-effects, cross-feature dependencies, caching/idempotency.

Components own local UI state via signals (as local as possible).

Signals are the default view contract: components expose readonly vm = computed(...).

ViewModels are pure mapping functions (mapToXxxVM) and are heavily unit-tested.

Routing is fast: route activates immediately; “entered” action fires; effects fetch; errors can redirect after the fact.

Recommended folder structure
features/
  foo-parent/
    store/
      foo-parent.actions.ts
      foo-parent.effects.ts
      foo-parent.reducer.ts
      foo-parent.selectors.ts
    routes.ts
    views/
      foo-parent-shell/
        foo-parent-shell.component.ts
        foo-parent-shell.component.html
        foo-parent-shell.component.css
        foo-parent-shell.viewmodel.ts
        foo-parent-shell.spec.ts

  foo/
    services/
      foo.api.ts
    store/
      foo.actions.ts
      foo.effects.ts
      foo.reducer.ts
      foo.selectors.ts
    routes.ts
    views/
      foo-page/
        foo-page.component.ts
        foo-page.component.html
        foo-page.component.css
        foo-page.viewmodel.ts
        foo-page.spec.ts
    components/
      foo-sidebar/
        foo-sidebar.component.ts
        foo-sidebar.component.html
        foo-sidebar.component.css
        foo-sidebar.viewmodel.ts
        foo-sidebar.spec.ts


Notes:

NgRx stays under store/.

VM mappers live beside the view/component they represent.

No presenter layer required.

Action naming (best practice)

Use a clear taxonomy:

Page / navigation events

[Foo Page] Entered

[Foo Parent Page] Entered

User intents

[Foo Sidebar] Selected Foo

[Foo Sidebar] Search Changed (optional—often local signal instead)

API results

[Foo API] Load Foo Success

[Foo API] Load Foo Failure

Commands

[Foo] Ensure Foo Loaded (if you like explicit “ensure” actions)

Routing pattern (dispatch on enter, no blocking)
features/foo-parent/routes.ts
export const routes = [
  {
    path: 'foo-parent',
    resolve: [() => inject(Store).dispatch(FooParentPageActions.entered())],
    children: [
      {
        path: 'foo/:id',
        loadChildren: () => import('../foo/routes').then(m => m.routes),
      },
      // ...
    ],
  },
];

features/foo/routes.ts
export const routes = [
  {
    path: '',
    component: FooPageComponent,
    resolve: [() => inject(Store).dispatch(FooPageActions.entered())],
  },
];


(These are “enter hooks”, not data resolvers; effect idempotency makes this safe.)

Effects (named by side-effect, idempotent, dependency-gated)
Foo-parent actions
foo-parent.actions.ts
export const FooParentPageActions = {
  entered: createAction('[Foo Parent Page] Entered'),
};

export const FooParentApiActions = {
  loadSuccess: createAction('[Foo Parent API] Load Success', props<{ data: FooParentData }>()),
  loadFailure: createAction('[Foo Parent API] Load Failure', props<{ error: unknown }>()),
};

Foo-parent effect
foo-parent.effects.ts
fetchFooParentData$ = createEffect(() =>
  this.actions$.pipe(
    ofType(FooParentPageActions.entered),
    concatLatestFrom(() => this.store.select(FooParentSelectors.selectLoaded)),
    filter(([, loaded]) => !loaded),
    switchMap(() =>
      this.api.getFooParentData().pipe(
        map(data => FooParentApiActions.loadSuccess({ data })),
        catchError(error => of(FooParentApiActions.loadFailure({ error })))
      )
    )
  )
);

Foo actions
foo.actions.ts
export const FooPageActions = {
  entered: createAction('[Foo Page] Entered', props<{ id: string }>()),
};

export const FooApiActions = {
  loadSuccess: createAction('[Foo API] Load Success', props<{ foo: Foo }>()),
  loadFailure: createAction('[Foo API] Load Failure', props<{ error: unknown }>()),
};

export const FooUiActions = {
  selected: createAction('[Foo Sidebar] Selected', props<{ id: string }>()),
};

Foo effect (waits for parent state inside effect, does not block route)
foo.effects.ts
fetchFooData$ = createEffect(() =>
  this.actions$.pipe(
    ofType(FooPageActions.entered),
    switchMap(({ id }) =>
      this.store.select(FooParentSelectors.selectSomethingNeededByFoo).pipe(
        filter(Boolean),
        take(1),
        switchMap(parentThing =>
          this.api.getFoo({ id, parentThing }).pipe(
            map(foo => FooApiActions.loadSuccess({ foo })),
            catchError(error => of(FooApiActions.loadFailure({ error })))
          )
        )
      )
    )
  )
);


(Optionally add idempotency checks against selectFooLoadedById(id) too.)

Component pattern (signals + NgRx selectSignal + pure VM mapping)
foo-sidebar.component.ts
@Component({ /* ... */ })
export class FooSidebarComponent {
  private readonly store = inject(Store);

  // Domain state (from NgRx as signals)
  private readonly foosS = this.store.selectSignal(selectFoos);
  private readonly selectedIdS = this.store.selectSignal(selectSelectedFooId);

  // Local UI-only state (signals)
  private readonly searchTextS = signal('');
  private readonly expandedS = signal(true);

  // View contract for template
  readonly vm = computed(() =>
    mapToFooSidebarVM({
      foos: this.foosS(),
      selectedId: this.selectedIdS(),
      searchText: this.searchTextS(),
      expanded: this.expandedS(),
    })
  );

  // UI intents
  setSearch(text: string) { this.searchTextS.set(text); }
  toggleExpanded() { this.expandedS.update(v => !v); }

  // Domain intents (dispatch)
  select(id: string) { this.store.dispatch(FooUiActions.selected({ id })); }
}

foo-sidebar.viewmodel.ts (pure)
export interface FooSidebarVM { /* ... */ }

export function mapToFooSidebarVM(input: {
  foos: Foo[];
  selectedId: string | null;
  expanded: boolean;
  searchText: string;
}): FooSidebarVM {
  // pure mapping; safe defaults; never throw
  return /* ... */;
}

Testing approach (best practice)
VM tests (highest ROI)

Unit test mapToFooSidebarVM / mapToFooPageVM as pure functions.

Effects tests

fetchFooParentData$:

when entered and not loaded → calls API → success/failure actions

fetchFooData$:

when [Foo Page] Entered but parent data missing → waits

once parent data present → calls API → success/failure

Component tests (optional)

Typically light: template wiring and event handlers.

Don’t re-test VM logic already covered by mapper tests.

One-liner “playbook”

Route enter dispatches PageEntered

Effects named after side-effects fetch/ensure

Effects are idempotent

Cross-feature dependencies are gated in effects (not guards)

Component owns local UI signals

VM mapping is pure and tested

If you want, paste your real action names (or a sample from a feature you’ve got) and I’ll align them with this taxonomy so it feels natural in your codebase rather than generic Foo/Bar